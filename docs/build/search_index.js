var documenterSearchIndex = {"docs":
[{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"EditURL = \"<unknown>/docs/lit/par_ldiv.jl\"","category":"page"},{"location":"par_ldiv/#parallel-ldiv!","page":"Parallel ldiv","title":"parallel ldiv!","text":"","category":"section"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"using SparseExtra, LinearAlgebra, SparseArrays, BenchmarkTools\nconst n = 10_000\nconst A = sprandn(n, n, 5 / n);\nconst C = A + I\nconst B = Matrix(sprandn(n, n, 1 / n));\nconst F = lu(C);\nconst X = similar(B);","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"Standard:","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"@benchmark ldiv!($X, $F, $B)","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"BenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took 96.309 s (0.00% GC) to evaluate,\n with a memory estimate of 0 bytes, over 0 allocations.","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"With FLoops.jl:","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"@benchmark par_solve!($X, $F, $B)","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"BenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took 25.195 s (0.00% GC) to evaluate,\n with a memory estimate of 1.24 MiB, over 163 allocations.","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"with manual loops","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"@benchmark par_ldiv!_t($X, $F, $B)","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"BenchmarkTools.Trial: 1 sample with 1 evaluation.\n Single result which took 25.395 s (0.00% GC) to evaluate,\n with a memory estimate of 1.24 MiB, over 130 allocations.","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"","category":"page"},{"location":"par_ldiv/","page":"Parallel ldiv","title":"Parallel ldiv","text":"This page was generated using Literate.jl.","category":"page"},{"location":"#SparseExtra","page":"Home","title":"SparseExtra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"DocTestSetup = :(using SparseArrays, LinearAlgebra, SparseExtra)","category":"page"},{"location":"","page":"Home","title":"Home","text":"SparseExtra.jl is a a series of helper function useful for dealing with sparse matrix, random walk, and shortest path on sparse graphs and some more. Most of this was developed for an unpublished paper which would help explain some of the design choises.","category":"page"},{"location":"#sparse-extra","page":"Home","title":"SparseExtra","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"SparseExtra.par_solve_f! \nSparseExtra.skip_row_to \nSparseExtra.extract_path \nSparseExtra.skip_col \nSparseExtra.IterateNZ\nSparseExtra.path_cost \nSparseExtra.GenericSparseMatrixCSC\nSparseExtra.path_cost_nt \nSparseExtra.DijkstraState\nSparseExtra.Path2Edge\nSparseExtra.par_solve! \nSparseExtra.dijkstra \nSparseExtra.iternz \nSparseExtra.par_inv!","category":"page"},{"location":"#SparseExtra.par_solve_f!","page":"Home","title":"SparseExtra.par_solve_f!","text":"like par_solve but use f and g to create the column (and then destroy it).\n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.skip_row_to","page":"Home","title":"SparseExtra.skip_row_to","text":"skip_row_to(::IterateNZ, ::S, i) -> S\n\nMove the cursor to the bottom of the i-1th element. Does nothing by default and only makes sense for matrices. \n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.extract_path","page":"Home","title":"SparseExtra.extract_path","text":"extract_path(::DijkstraState{T, U}, d) -> U[]\n\nreturn the path found to d.\n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.skip_col","page":"Home","title":"SparseExtra.skip_col","text":"skip_col(::IterateNZ, ::S) -> S\n\nMove the cursor to the bottom of the current column. Does nothing by default and only makes sense for matrices.\n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.IterateNZ","page":"Home","title":"SparseExtra.IterateNZ","text":"Helper structure for iternz, all methods. iternz just returns this wrapper and the Base.iterate method is overloaded.\n\n\n\n\n\n","category":"type"},{"location":"#SparseExtra.path_cost","page":"Home","title":"SparseExtra.path_cost","text":"path_cost(::AbstractSparseMatrixCSC, r, n)\n\nreturn the total weight  of the path r[1:n]\n\n\n\n\n\npath_cost(f::Function, ::AbstractSparseMatrixCSC, r, n)\n\nreturn the total weight of the path r[1:n], with f applied to each weight before summation\n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.GenericSparseMatrixCSC","page":"Home","title":"SparseExtra.GenericSparseMatrixCSC","text":"Like SparseMatrixCSC but allows any container for the vectors tho they should all be Dense 1-indexed Vectors\n\n\n\n\n\n","category":"type"},{"location":"#SparseExtra.path_cost_nt","page":"Home","title":"SparseExtra.path_cost_nt","text":"path_cost_nt(::AbstractSparseMatrixCSC, r, n)\n\nlike path_cost, but for matrices that are transposed\n\n\n\n\n\npath_cost_nt(f::Function, ::AbstractSparseMatrixCSC, r, n)\n\nlike path_cost, but for matrices that are transposed\n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.DijkstraState","page":"Home","title":"SparseExtra.DijkstraState","text":"Work structure for `dijkstra`\n\n\n\n\n\n","category":"type"},{"location":"#SparseExtra.Path2Edge","page":"Home","title":"SparseExtra.Path2Edge","text":"Path2Edge(x, [e=length(x)])\n\n[Unbenchmarked] faster version of zip(view(x, 1:e), view(x, 2:e)). Only works on 1-index based arrays with unit strides\n\n\n\n\n\n","category":"type"},{"location":"#SparseExtra.par_solve!","page":"Home","title":"SparseExtra.par_solve!","text":"ldiv! but in parallel. use colsto skip columns andf(col, index)` to apply a thread safe function to that column.\n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.dijkstra","page":"Home","title":"SparseExtra.dijkstra","text":"dijkstra(distmx::AbstractSparseMatrixCSC, state::DijkstraState, [target]) -> Nothing\n\nGiven a distmx such that distmx[j, i] is the distance of the arc i→j and strucutral zeros mean no arc, run the dijkstra algorithm until termination or reaching target (whichever happens first).\n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.iternz","page":"Home","title":"SparseExtra.iternz","text":"`iternz(x)`\n\nshortcut for IterateNZ.\n\n\n\n\n\n","category":"function"},{"location":"#SparseExtra.par_inv!","page":"Home","title":"SparseExtra.par_inv!","text":"return lu \\ I\n\n\n\n\n\n","category":"function"},{"location":"iternz/","page":"iternz","title":"iternz","text":"EditURL = \"../lit/iternz.jl\"","category":"page"},{"location":"iternz/#The-iternz-API","page":"iternz","title":"The iternz API","text":"","category":"section"},{"location":"iternz/","page":"iternz","title":"iternz","text":"This returns an iterator over the structural non-zero elements of the array (elements that aren't zero due to the structure not zero elements) i.e.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"all(iternz(x)) do (v, k...)\n    x[k...] == v\nend","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"The big idea is to abstract away all of the speciall loops needed to iterate over sparse containers. These include special Linear Algebra matrices like Diagonal, and UpperTriangular or SparseMatrixCSC. Furethemore it's possible to use this recursively i.e. An iteration over a Diagonal{SparseVector} will skip the zero elements (if they are not stored) of the SparseVector.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"For an example let's take the sum of the elements in a matrix such that (i + j) % 7 == 0. The most general way of writing it is","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"using BenchmarkTools, SparseArrays\nconst n = 10_000\nconst A = sprandn(n, n, max(1000, 0.1 * n*n) / n / n);\n\nfunction general(x::AbstractMatrix)\n    s = zero(eltype(x))\n    @inbounds for j in axes(x, 2),\n        i in axes(x, 1)\n        if (i + j) % 7 == 0\n            s += x[i, j]\n        end\n    end\n    return s\nend\n@benchmark general($A)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"BenchmarkTools.Trial: 11 samples with 1 evaluation.\n Range (min … max):  461.048 ms … 468.458 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     463.496 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   463.928 ms ±   2.200 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n                                       █                         \n  ▇▁▇▁▁▁▁▁▁▁▇▁▁▁▇▇▁▁▁▁▇▁▁▇▁▁▁▁▁▁▁▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▇ ▁\n  461 ms           Histogram: frequency by time          468 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"Now this is pretty bad, we can improve the performance by using the sparse structure of the problem","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"using SparseArrays: getcolptr, nonzeros, rowvals\n\nfunction sparse_only(x::SparseMatrixCSC)\n    s = zero(eltype(x))\n    @inbounds for j in axes(x, 2),\n        ind in getcolptr(x)[j]:getcolptr(x)[j + 1] - 1\n\n        i = rowvals(x)[ind]\n        if (i + j) % 7 == 0\n            s += nonzeros(x)[ind]\n        end\n    end\n    return s\nend","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"sparse_only (generic function with 1 method)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"We can test for correctness","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"sparse_only(A) == general(A)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"true","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"and benchmark the function","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"@benchmark sparse_only($A)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"BenchmarkTools.Trial: 301 samples with 1 evaluation.\n Range (min … max):  15.765 ms …  19.260 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     16.511 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   16.646 ms ± 566.611 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n       ▁▃▅▄█▃▄ ▃ ▁▄   ▁                                         \n  ▃▁▃▃▄█████████▇██▆▅▇██▅▆▅█▇▅▃▆▅▃▆▅▆▄▃▄▁▁▃▁▄▃▅▃▁▃▁▁▃▃▁▁▁▁▁▃▁▃ ▄\n  15.8 ms         Histogram: frequency by time         18.6 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"we can see that while writing the function requires understanding how CSC matrices are stored, the code is 600x faster. The thing is that this pattern gets repeated everywhere so we might try and abstract it away. My proposition is the iternz api.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"using SparseExtra\n\nfunction iternz_only(x::AbstractMatrix)\n    s = zero(eltype(x))\n    for (v, i, j) in iternz(x)\n        if (i + j) % 7 == 0\n            s += v\n        end\n    end\n    return s\nend\niternz_only(A) == general(A)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"true","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"@benchmark sparse_only($A)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"BenchmarkTools.Trial: 266 samples with 1 evaluation.\n Range (min … max):  15.932 ms … 32.230 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     17.630 ms              ┊ GC (median):    0.00%\n Time  (mean ± σ):   18.806 ms ±  2.971 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n    ▄█▅▂█▁▃                                                    \n  ▅█████████▄▅▅▆▅▆▆▄▄▄▄▅▃▁▃▄▃▄▃▁▅▄▁▃▃▃▁▁▃▁▃▃▃▁▄▃▃▁▁▃▃▃▁▃▃▁▁▃▃ ▃\n  15.9 ms         Histogram: frequency by time        28.3 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"The speed is the same as the specialized version but there is no @inbounds, no need for ugly loops etc. As a bonus point it works on all of the specialized matrices","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"using LinearAlgebra\nall(iternz_only(i(A)) ≈ general(i(A)) for i in [Transpose, UpperTriangular, LowerTriangular, Diagonal, Symmetric]) # symmetric changes the order of exection.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"true","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"Since these interfaces are written using the iternz interface themselves, the codes generalize to the cases where these special matrices are combined, removing the need to do these tedious specialization.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"For instance the 3 argument dot can be written as","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"function iternz_dot(x::AbstractVector, A::AbstractMatrix, y::AbstractVector)\n    (length(x), length(y)) == size(A) || throw(ArgumentError(\"bad shape\"))\n    acc = zero(promote_type(eltype(x), eltype(A), eltype(y)))\n    @inbounds for (v, i, j) in iternz(A)\n        acc += x[i] * v * y[j]\n    end\n    acc\nend\n\n\nconst (x, y) = randn(n), randn(n);\nconst SA = Symmetric(A);","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"Correctness tests","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"dot(x, A, y) ≈ iternz_dot(x, A, y) && dot(x, SA, y) ≈ iternz_dot(x, SA, y)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"true","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"Benchmarks","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"@benchmark dot($x, $A, $y)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"BenchmarkTools.Trial: 500 samples with 1 evaluation.\n Range (min … max):  9.153 ms …  16.797 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     9.794 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   9.998 ms ± 744.517 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n    ▃    ▂▄█▃ ▁                                                \n  ██████▇██████▆█▅▄▄▅▄▄▄▄▄▄▅▄▄▄▃▄▃▄▄▃▃▃▁▃▁▁▂▂▂▁▂▁▁▁▁▁▁▁▁▁▁▁▁▂ ▄\n  9.15 ms         Histogram: frequency by time        12.9 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"@benchmark iternz_dot($x, $A, $y)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"BenchmarkTools.Trial: 426 samples with 1 evaluation.\n Range (min … max):  10.760 ms …  16.682 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     11.519 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   11.727 ms ± 741.895 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n         ▅█▄▁▂▂                                                 \n  ▅▇▇▆█▇▇████████▆█▄▆██▆▄▆▄▆▅▆▃▄▄▃▄▂▄▃▃▂▂▁▃▁▁▁▂▃▁▁▃▁▃▁▁▁▃▃▁▁▁▂ ▄\n  10.8 ms         Histogram: frequency by time         14.5 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"@benchmark dot($x, $SA, $y)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"BenchmarkTools.Trial: 9 samples with 1 evaluation.\n Range (min … max):  607.881 ms … 623.882 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     609.728 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   611.193 ms ±   4.900 ms  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n  ▁  █ ▁ ▁█      ▁                                            ▁  \n  █▁▁█▁█▁██▁▁▁▁▁▁█▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁▁█ ▁\n  608 ms           Histogram: frequency by time          624 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"@benchmark iternz_dot($x, $SA, $y)","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"BenchmarkTools.Trial: 440 samples with 1 evaluation.\n Range (min … max):  10.576 ms …  17.101 ms  ┊ GC (min … max): 0.00% … 0.00%\n Time  (median):     11.173 ms               ┊ GC (median):    0.00%\n Time  (mean ± σ):   11.371 ms ± 740.788 μs  ┊ GC (mean ± σ):  0.00% ± 0.00%\n\n   ▂▃   █▆▃▄▃                                                   \n  ▆███████████▇▆▇▇▅▆▆▆▅▄▅▅▃▄▃▃▃▃▃▂▁▂▁▁▂▂▃▁▃▁▁▂▂▁▂▁▁▁▂▁▁▁▃▁▁▁▁▂ ▃\n  10.6 ms         Histogram: frequency by time         14.4 ms <\n\n Memory estimate: 0 bytes, allocs estimate: 0.","category":"page"},{"location":"iternz/#API:","page":"iternz","title":"API:","text":"","category":"section"},{"location":"iternz/","page":"iternz","title":"iternz","text":"The Api is pretty simple, the iternz(A) should return an iteratable such that","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"all(A[ind...] == v for (v, ind...) in iternz(A))","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"If the matrix is a container for a different type, the inner iteration should be done via iternz. This repo provides the IterateNZ container whose sole pupose is to hold the array to overload Base.iterate. Additionally matrices have the skip_col and skip_row_to functions defined. The idea that if meaningful, this should return a state such that iterating on that state will give the first element of the next column or in the case of skip_row_to(cont, state, i), iterate should return (i, j) where j is the current column.","category":"page"},{"location":"iternz/#TODO","page":"iternz","title":"TODO","text":"","category":"section"},{"location":"iternz/","page":"iternz","title":"iternz","text":"test with non-one based indexing","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"","category":"page"},{"location":"iternz/","page":"iternz","title":"iternz","text":"This page was generated using Literate.jl.","category":"page"}]
}
